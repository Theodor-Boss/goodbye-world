<!DOCTYPE html>
<html>
<head lang="da-DK">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penduler</title>
    <!-- <link rel="icon" href="../img/andersand.webp"> -->
    <link rel="icon" href="img/pendulum3.png">
    <link rel="stylesheet" href="../css/reset.css">
    <link rel="stylesheet" href="../css/main.css">
    <link rel="stylesheet" href="css/main.css">

    <!-- LaTeX -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Prism.js CSS for the theme -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

    <!-- Prism.js JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q6G8BFEWN6"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-Q6G8BFEWN6');
    </script>
</head>
<body>
    <header class="header-main">
        <div class="site-title">theodormyhre.dk</div>
        <nav></nav>
        <div></div>
    </header>

    <h1>Studieretningsprojekt: Vektorfelter og fysiske penduler</h1>

    <div class="layout">
    <p>
        Dette er highlights fra mit studieretningsprojekt i gymnasiet, som jeg skrev i matematik A og fysik A.
        <br>
        Opgaven handlede om at beskrive et fysisk pendul med en differentialligning. Og at bruge vektorfelter i den forbindelse.
        <span class="brlarge"></span>

        <img src="img/github.jfif" alt="" style="width: 70px;">
        <a target="_blank" href="https://github.com/Theodor-Boss/SRP/tree/main">Link til min GitHub-repository</a> hvor det meste af min Python-kode ligger. Jeg henviser løbende til relevante filer, bare hold øje med GitHub-ikonet.
    </p>
    <div class="gif">
        <img id="vektorfelt1" src="img/vektorfelt.png" alt="">
    </div>
</div>

<div class="layout">
    <h2>Resumé</h2>
    <p>
        I det her projekt opstillede jeg en differentialligning for et fysisk penduls bevægelse med dæmpning. Jeg bruger et vektorfelt/faserum til at løse differentialligningen numerisk. Desuden udvikler jeg en række numeriske metoder til at trække information ud af mine 26.000 målepunkter.
    </p>
    <h2>Credit</h2>
    <p>
        Idéen til min SRP har jeg egentlig tyvestjålet fra 3b1b. Eller lad mig sige det sådan: Meget af teorien i opgaven bærer tydeligt præg af hans fremragende video om stoffet:
        <span class="brlarge"></span>
        <a target="_blank" href="https://www.3blue1brown.com/lessons/differential-equations">3b1b: Differential equations, studying the unsolvable</a>
        <span class="brlarge"></span>
        Det originale i min opgave er at jeg opstiller en differentialligning der gælder for et hvilket som helst stift pendul, hvor 3b1b fokusserer på det simple pendul. Desuden antager 3b1b, at friktionen i pendulet er proportional med vinkelhastigheden \(\dot{\theta}=\frac{d\theta}{dt}\), hvor jeg prøver at gå et spadestik dybere og lave fysiske målinger af pendulet i et forsøg på at afdække den nøjagtige sammenhæng mellem dæmpningen og vinkelhastigheden \(\dot{\theta}\) (og om dæmpningen evt. også kunne afhænge af vinklen \(\theta\)). Dvs. min tilgang er både teoretisk og empirisk.
    </p>
    <h2>Teori</h2>
    <p>
        Ved hjælp af nogle fysiske overvejelser, kan man komme frem til at en realistisk model af et fysisk pendul med friktion kan beskrives med denne differentialligning:
    </p>
</div>
    \[
    \boxed{
    \huge \ddot{\theta} = \mu(\dot{\theta}) + \frac{mgd}{I}sin(\theta)
    }
    \]
<div class="layout">
    <p>
        Forklaring:
        <ul>
            <li>
                \(\theta\) (theta) er vinklen målt i radianer. Vi bestemmer, at pendulet har en vinkel på 0 radianer, når det er lodret, altså når massemidtpunktet befinder sig direkte under rotationsaksen, hvilket medfører, at den potentielle energi er mindst ved \(\theta=0\). Vi bestemmer, at vinklen stiger, når pendulet drejer modsat urets retning (og vinkel bliver dermed mere negativ, når pendulet drejer med urets retning).
            </li>
            <li>
                \(\dot{\theta}=\frac{d\theta}{dt}\) er vinkelhastigheden, dvs. vinklen differentieret (nogle gange bruges i stedet \(\omega\) (omega). Det har jeg fx gjort i koden). Den måles i radianer per sekund, og er et mål for, hvor hurtigt pendulet drejer. Det følger af det, vi har besluttet om vinklen, at en positiv vinkelhastighed svarer til, at pendulet drejer modsat urets retning.
            </li>
            <li>
                \(\ddot{\theta}=\frac{d^2\theta}{dt^2}\) er vinkelaccelerationen, dvs. vinkelhastigheden differentieret, eller vinklen differentieret to gange (nogle gange bruges i stedet \(\alpha\) (alpha). Det har jeg fx gjort i koden). Den måles i radianer per sekund per sekund, og er et mål for, hvor hurtigt pendulet ændrer hastighed.
            </li>
            <li>
                \(\mu(\dot{\theta})\) er en funktion, der angiver sammenhængen mellem friktionen og vinkelhastigheden. I 3b1b's video antages det, at \(\mu(\dot{\theta})=-\mu\cdot\dot{\theta}\), men den kunne i princippet være mere kompliceret.
            </li>
            <li>
                \(m\) er den masse, der er i bevægelse, fx lod plus arm.
            </li>
            <li>
                \(g\) er tyngdeaccelerationen.
            </li>
            <li>
                \(d\) er afstanden fra massemidtpunktet til omdrejningsaksen.
            </li>
            <li>
                \(I\) er intertimomentet i pendulet ift. omdrejningsaksen.
            </li>
        </ul>
    </p>
    <p>
        Differentialligningen kan udledes vha. nogle fysiske love. Her vil jeg fremhæve loven \(\sum \vec{\tau}=\vec{\alpha} \cdot I\). Dvs. at vinkelaccelrationen er proportional med det resulterende kraftmoment (torque) på pendulet, dvs. den kraft der drejer det.
        <span class="brsmall"></span>
        Logikken i modellen bygget direkte på den lov. Overordnet set er der nemlig to kraftmomenter, der virker på pendulet: 
        <ul>
            <li>
                Dæmpningen, som er en samlebetegnelse for gnidningen/friktionen/luftmodstanden 
            </li>
            <li>
                Vægten pga. tyngdekraften.
            </li>
        </ul>
    </p>
    <p>

    
        Ifølge loven fås vinkelaccelerationen (som er interessant for os) altså ved at lægge alle kraftmomenter sammen og dele med inertimomentet \(I\).
        <span class="brsmall"></span>
        Jeg vil ikke gå i detaljer med udledningen af kraftmomentet fra tyngdekraften, men det involverer at tage krydsproduktet mellem tyngdekraften og vektoren fra omdrejningspunktet til massemidtpunktet. (Størrelsen af) det giver \(mgd \cdot sin(\theta)\).
        <span class="brlarge"></span>
    </p>
    <h2>Løsningen</h2>
    <p>
        Vi er interesserede i løsningen til differentialligningen, altså en funktion \(\theta(t)\). Der findes ingen analytisk løsning i dette tilfælde, men vi kan stadig løse det numerisk. Tænkt det sådan her:
        <br>
        Antag at de fire konstanter \(m\), \(g\), \(d\) og \(I\) er kendt og at du kender funktionen \(\mu(\dot{\theta})\). Lad os sige og at du kender startvinklen \(\theta_0\) og startvinkelhastigheden \(\dot{\theta}_0\). Vha. disse kan du udregne startvinkelaccelerationen \(\ddot{\theta}_0\) ved blot at indsætte de kendte værdier i ligningen. Vi ønsker at løse differentialligningen numerisk, hvilket er en anden måde at sige at vi gerne vil forudsige pendulets bevægelse i fremtiden.
        <br>
        Vi kender pendulets starttilstand \((\theta, \dot{\theta})\). Vi kan ikke umiddelbart beregne en vilkårlig tilstand langt ude i fremtiden, men vi kan faktisk beregne, tilstanden efter en lille tidsskridt. Ved at tage mange små tidsskridt, vil vi før eller siden nå frem til det ønskede tidspunkt der kan ligge langt ude i fremtiden.
        <br>
        Vi kan let regne os frem til en kommende tilstand, hvis denne tilstand kun kræver et lille tidsskridt. Det er her, vektorfeltet/faserummet kommer ind i billedet.
    </p>
    <h2><a href="#vektorfelt1">Vektorfeltet</a></h2>
    <p>
        Som vist øverst kan man opstille et vektorfelt, som angiver hvordan en given tilstand ændrer sig, som systemet udvikler sig. Man kan tænkte det sådan, at vektorerne i vektorfeltet angiver den hastighed tilstanden \((\theta, \dot{\theta})\)bevæger sig med i dette abstrakte faserum.
        <br>
        En anden måde at sige det samme på: Vektorfeltet knytter den differenteirede tilstand til hver tilstand i faserummet \((\theta, \dot{\theta})\).
        <span class="brlarge"></span>
        Det kan være svært at forestille sig, så jeg har prøvet at illustrere idéen her:
    </p>
    <div class="gif">
        <img id="evolution" src="img/evolution.gif" alt="">
    </div>
    <p>
        
        <img src="img/github.jfif" alt="" style="width: 70px;"> Se filen <a target="_blank" href="https://github.com/Theodor-Boss/SRP/blob/main/TryMe1.py">TryMe1.py</a> i min GitHub-repository for koden bag animationen. Matematikken i koden forklares på denne side.
        <span class="brlarge"></span>

        Bemærk at den røde prik følger vektorerne. Bemærk desuden at farten af det røde punkt svarer til længden af den vektor den er på. Nogle vektorer har en længde på 0. Dvs. at tilstanden er i balance.
        <span class="brmedium"></span>
        Den røde priks positions er \(\begin{pmatrix}\theta \\ \dot{\theta} \end{pmatrix}\). Den bevæger sig pr. def. i dette abstrakte rum med hastigheden \(\frac{d}{dt} \begin{pmatrix}{\theta} \\ \dot{\theta} \end{pmatrix}=\begin{pmatrix}\dot{\theta} \\ \ddot{\theta} \end{pmatrix}\).
        <span class="brmedium"></span>
        Da \(\ddot{\theta}\) kan beregnes ud fra tilstanden, har vi altså en måde at beregne tilstanden differentieret.
        <span class="brlarge"></span>
        Dette kan selvfølgelig implementeres i Python:
    </p>

    <div class="python-code">
<pre><code class="language-python">import numpy as np

mu = 0.3  # Dæmpningsfaktor
mgdI = 3.0  # De fire konstanter samlet til én faktor
THETA_0 = 3.14159 - 2 * np.pi
THETA_DOT_0 = 0


def get_theta_double_dot(theta, theta_dot):
    return -mu * theta_dot - mgdI * np.sin(theta)

def theta(t, delta_t):
    theta = THETA_0
    theta_dot = THETA_DOT_0
    for time in np.arange(0, t, delta_t):
        theta_double_dot = get_theta_double_dot(theta, theta_dot)
        theta += theta_dot * delta_t
        theta_dot += theta_double_dot * delta_t
    return theta
</code></pre>
    </div>
    <p>
        
    </p>
</div>


<div class="layout">

    <p>
        Her er tanken, at <code class="language-python">mu</code>, <code class="language-python">mgdI</code>, <code class="language-python">THETA_0</code> og <code class="language-python">THETA_DOT_0</code> er globale variabler.
    </p>

    <h2>Empiri</h2>
    <p>
        Som sagt lavede jeg også noget dataindsamling. Formålet var at verificere modellen og evt. bestemme konstanterne i modellen og sammenhængen mellem vinkelhastigheden og dæmpningen.
        <span class="brmedium"></span>

        Det jeg havde brug for var en masse sammenhørende målinger af vinklen, vinkelhastigheden og vinkelaccelerationen for et eller andet fysisk pendul. Spørgsmålet var hvordan.
        <span class="brmedium"></span>
        
        Første step var at konstruere et pendul. Jeg valgte at montere et 500g-lod på mit cykelhjuls fælg. Det var en god idé, da det
    </p>
    <ul>
        <li>
            var stift (formlen gælder kun for stive legemer)
        </li>
        <li>
            kunne dreje hele vejen rundt (giver mulighed for at fylde større dele af faserummet ud med målepunkter)
        </li>
    </ul>
    <p>
        Næste step var at finde en måde at måle vinklen, vinkelhastigheden og vinkelaccelerationen en hel masse gange. Jeg overvejede først videoanalyse. Jeg fik dog hurtigt en bedre idé:
        <br>
        At bruge min telefons indbyggede gyroskop til at måle vinkelhastigheden. Ved at montere telefonen på hjulet fik jeg optaget ~26.000 sammenhørende værdier af tid og vinkelhastighed fordelt på 5 måleserier vha. app'en  SenserLogger.
    </p>
    <BR></BR>
    <h2>Efterbehandling</h2>
    <p>
        Step 1 i efterbehandlingen var at gå fra data på formen \(\begin{pmatrix} t \\ \dot{\theta} \end{pmatrix}\) til data på formen \(\begin{pmatrix} \theta \\ \dot{\theta} \\ \ddot{\theta} \end{pmatrix}\). Det kan virke lidt underligt, at det kan lade sig gøre - at denne information kan trækkes ud af dataene - men det har noget at gøre med, at meget af informationen er opbevaret i <span class="kursiv">relationen</span> mellem datapunkterne.
        <br>
        Fx finder man vinklen ved at integrere vinkelhastigheden mht. tiden, og vinkelaccelerationen ved at differentiere vinkelhastigheden mht. tiden - begge har at gøre med relationen mellem dataene.
    </p>
    <h3>Kalibrering af vinkelhastigheden</h3>
    <p>
        Men første step var altså at kalibrere vinkelhastigheden.
        Det var nemlig ikke gjort i appen...
        <br>
        Her et plot over mine data hvor fejlen illustreres:
        <br>
        <img src="img/Ikkekalibreret_vinkelhastighed_ani.gif" alt="">
        <br>
        Det ses, hvis man zoomer ind på det røde område, at det ikke er nul (den vandrette linje), som det burde være, eftersom hjulet stod stille.
        <br>
        <img src="img/github.jfif" alt="" style="width: 70px;"> Se <a target="_blank" href="https://github.com/Theodor-Boss/SRP/blob/main/TryMe2.py">TryMe2.py</a> i min GitHub-repository for koden bag animationen. Sørg for også at downloade "extracted_data1.npz"
        <BR></BR>
        Lad os fikse det med noget matematik:
        <br>
        Vores ikke-kalibrerede vinkelhastighed \(\omega_{off}(t)\) er forskudt med konstanten \(c_{off}\), således at:
    </p>
</div>
<div id="omega_off">
\[
\huge \omega_{off}(t) = \omega(t) + c_{off}
\]
</div>
<div class="layout">
    <p>
        <img src="img/c_off.png" alt="">
        <br>
        Vi ønsker altså at bestemme \(c_{off}\).
        <BR></BR>
        Det er der mange måder at gøre på. Jeg valgte en, jeg er rigtig godt tilfreds med:
        <br>
        Vi kan nemlig integrere den ikke-kalibrerede vinkelhastighed, og foretage en lineær regression i det røde interval. Ved at integrere \(\omega_{off}(t)\) altså finde en stamfunktion til den, får vi følgende:
    </p>
</div>
\[
\Large \int \omega_{off}(t) dt = \int (\omega(t) + c_{off}) dt = \int \omega(t) dt + c_{off} \cdot t
\]
<div class="layout">
    <p>
        Det der står er, at hvis man integrerer den ikke-kalibrerede vinkelhastighed, får man \(c_{off} \cdot t\) plus en stamfunktion til den ægte vinkelhastighed \(\omega(t)\), som er konstant, når pendulet står stille. 
        <br>
        Med andre ord: En stamfunktion til den ikke-kalibrerede vinkelhastighed er en ret linje i tidsintervallet, hvor pendulet stod stille. Denne linjes hældning er \(c_{off}\). Vi kan foretage lineær regression for at finde denne. Når \(c_{off}\) er bestemt, kan vi finde den ægte vinkelhastighed \(\omega(t)\) ved at isolere den i formlen <a href="#omega_off">ovenfor</a>.
        <br>
        <img src="img/Stamfunktion-regression.gif" alt="">
        <br>
        <img src="img/github.jfif" alt="" style="width: 70px;"> Se <a target="_blank" href="https://github.com/Theodor-Boss/SRP/blob/main/TryMe3.py">TryMe3.py</a> for selv at køre animationen og se koden bag.
        
        <span class="brlarge"></span>
        
        Figuren viser en stamfunktion til den ikke-kalibrerede vinkelhastighed. Der er foretaget lineær regresion på det røde område (hvor pendulet er gået i stå). Bemærk linjens hældning, der bliver tydelig, når akserne justeres.
        <BR></BR>
        Jeg bruger den her algoritme til at finde en stamfunktioner med:
    </p>
</div>

<div class="python-code">
<pre><code class="language-python">def antiderivative(xs, ys):
    h = np.diff(xs)
    a1 = ys[:-1]
    a2 = ys[1:]
    trapez_sum = 0.5 * (a1 + a2) * h
    integrals = np.concatenate(([0], np.cumsum(trapez_sum)))
    return integrals
</code></pre>
    </div>

<div class="layout">
    <p>
        Metoden bygger på den berømte relation mellem bestemte og ubestemte integraler:
    </p>
</div>
\[
\huge \int_{a}^{b} f(x)dx = F(b) - F(a)
\]

<div class="layout">
    <p>
        hvor \(F\) er en stamfunktion til \(f\).
        <br>
        Hvis man ønsker at finde en stamfunktion til \(f\), kan man nemlig sætte \(b=x\) og isolere \(F(x)\):
    </p>
</div>

\[
\huge \int_{a}^{x} f(x)dx = F(x) - F(a) \Longleftrightarrow F(x) = \int_{a}^{x} f(x)dx + F(a)
\]

<div class="layout">
    <p>
        \(F(a)\) er en konstant, så \(\int_{a}^{x} f(x)dx\) er også en stamfunktion til \(f\). Vi kan altså lige så fint udregne den. \(a\) kan desuden vælges frit blandt de reelle tal.
        <BR></BR>
        <code class="language-python">antiderivative()</code> bruger den såkaldte trapezmetode til at evaluere dette integral.
        <br>
        <img src="img/trapez approksimation.png" alt="">
        <br>
        Jeg minder om, at et bestemt integral svarer til arealet mellem kurven og \(x\)-aksen (hvis kurven er positiv - hvis kurven er negativ er integralet negativt). Så ved at approksimere arealet under kurven med trapezer i intervallet \(a\) og \(x\) fås en stamfunktion.
        <BR></BR>
        Koden nedenfor bruges til at kalibrere vinkelhastigheden.
        <br>
        
        
        <img src="img/github.jfif" alt="" style="width: 70px;"> Se <a target="_blank" href="https://github.com/Theodor-Boss/SRP/blob/main/TryMe4.py">TryMe4.py</a> for koden bag.
        
        <span class="brlarge"></span>

    </p>
</div>

<div class="python-code">
    <pre><code class="language-python">def antiderivative(xs, ys):
    h = np.diff(xs)
    a1 = ys[:-1]
    a2 = ys[1:]
    trapez_sum = 0.5 * (a1 + a2) * h
    integrals = np.concatenate(([0], np.cumsum(trapez_sum)))
    return integrals  # dvs. det ubestemte integral for y(x) gennem (xs[0],0)


def calibrate_omega(ts, omegas, hvile):
    """
    "hvile" er en tuple som angiver
    tidsintervallet, pendulet er i hvile.
    """
    stamfunktion = antiderivative(ts, omegas)
    mask_hvile = (ts >= hvile[0]) & (ts < hvile[1])
    X_train, X_test, y_train, y_test = train_test_split(
        ts[mask_hvile].reshape(-1, 1), stamfunktion[mask_hvile],
        test_size=0.2, random_state=42
    )
    model = LinearRegression()
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    mse = mean_squared_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)
    slope = model.coef_[0]
    kalibreret_omegas = omegas - slope
    return kalibreret_omegas, r2, mse</code></pre></div>

<div class="layout">
    
</div>

<div class="layout">
    <h2><a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ">Fortsæt med at generere</a></h2>
</div>

<!-- \frac{d^2\theta}{dt^2} -->
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>

    <div class="footer">Opdateret 6. september 2024</div>


</body>
</html>